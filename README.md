# note
## C++
1. **右值、移动语义、完美转发及配合lambda**  
   采用**右值**和**移动语义**主要是避免进行过多的副本复制，从而节省系统资源，提高效率  
   
   **右值**：表达式结束时就不存在的临时对象，例如函数返回值，运算表达式等，最简单的查看方法是
   看能否对该值取地址，能则是左指，不能则是右值。  
   
   **左值引用、右值引用**：`&&`表示右值引用，只能绑定右值。 `&`表示左值引用，只能绑定左值。`const &`例外，左值右值都能绑定。模板类`T &&`也都能绑定（也称为通用引用），进行自动推断。 
   
   **右值用法**：通常的拷贝复制函数，和赋值运算函数（=号运算，也会隐式调用复制函数），这些值作为临时的参数值传递给函数时（有的编译器会优化，先不考虑编译器优化），一般会先调用构造函数构建对象，然后在会创建临时的副本接收这个对象，然后传递给函数，这样就造成了资源浪费。采用右值就会告诉编译器，不需要再创建副本，直接把对象传递给函数。具体做法就是构建**移动语义复制构造函数**和**移动语义赋值函数**，例如一个类`MyString`有一个私有变量字符串`char *m_data`,则他的移动赋值构造函数如下
   ```
   MyString(MyString&& str) noexcept
       :m_data(str.m_data) {
       str.m_data = nullptr; //不再指向之前的资源了
   }
   ```
   例如当在`push_back(MyString("hello))`时候，`MyString("hello)`作为临时变量，默认的会新建一个临时副本存储它，然后放入内存。而调用**移动语义赋值**则直接把要添加位置的内存指针指向这个临   时变量。可以理解为移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是"偷"了过来，将自己的指针指向别人的资源，然后将别人的指针修改为`nullptr`,最后把别人的指   针置空也很重要，不置空的话，这个临时对象析构后则后面继承的指针则无数据可以操控，而且后面这个对象的析构也可能会对对同一个地址释放，则会出现不可知的情况。（用`emplace_back()`等效移动语义）  
   调用`std::move()`可以把左值转换成右值  
   
   **完美转发**：所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。  
   ```  
   void process(int& i){
    cout << "process(int&):" << i << endl;
   }
   void myforward(int&& i){
      cout << "myforward(int&&):" << i << endl;
      process(i);
   }

   int main(){
   int a = 0;
   myforward(2);  //右值经过forward函数转交给process函数，却称为了一个左值，
   //原因是该右值有了名字  所以是 process(int&):2
   myforward(move(a));  // 同上，在转发的时候右值变成了左值  process(int&):0
   // forward(a) // 错误用法，右值引用不接受左值
   }  
   ```     
   调用模板类和`std::forward()`则可以解决  
  ```  
  template<typename T>
  void myforward(T && t){
      process(std::forward<T>(t));
  }  
  ```  
  
## 计算机网络

## 网络编程
### 信号
1. **signal信号** :signal信号是进程之间相互传递消息的一种方法，信号全称为软中断信号  
信号只是用来通知某进程发生了什么事件，无法给进程传递任何数据，进程对信号的处理方法有三种：   
   * 第一种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。  
   * 第二种是设置中断的处理函数，收到信号后，由该函数来处理。  
   * 第三种方法是，对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程。
2. **常见信号** :下面是常用到的几个信号  
   信号名|信号值|信号动作|发出的原因
   --|:--:|:--:|--:
   SIGINT|2|终止进程|键盘ctrl+c
   SIGKILL|9|强制终止，无法忽略|发出命令kill -9
   SIGSEGV|11|缺省的动作是终止进程并进行内核映像转储（core dump）|无效的内存引用
   SIGTERM|15|终止进程|发出命令kill
   SIGCHLD|20,17,18|忽略信号|子进程结束信号  
3. **可靠信号/不可靠信号**：1-32是不可靠信号， 34-64是可靠信号。  
   不可靠信号主要会出现信号丢失问题：如果多次发送同一个信号可能会出现丢失，只接受到部分信号。  
4. **信号中断**: 多次同一个信号（可靠信号）会阻塞等待，如果发送其他信号，会优先处理新的信号，等处理函数结束再处理原信号。
5. **信号有什么用**： 服务程序运行在后台，如果想让中止它，强行杀掉不是个好办法，因为程序被杀的时候，程序突然死亡，没有释放资源，会影响系统的稳定，用Ctrl+c中止与杀程序是相同的效果。如果能向后台程序发送一个信号，后台程序收到这个信号后，调用一个函数，在函数中编写释放资源的代码，程序就可以有计划的退出，安全而体面。  
6. **信号的用法**：
   * `sighandler_t signal(int signum, sighandler_t handler);` 第一个参数：信号值， 第二个参数处理函数(SIG_IGN忽略)；
   * `int kill(pid_t pid, int sig);`   
   kill函数将参数sig指定的信号给参数pid 指定的进程。参数pid 有几种情况：  
      1. pid>0 将信号传给进程号为pid 的进程。  
      2. pid=0 将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号。
      3. pid=-1 将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息。  
   sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。  
   返回值说明： 成功执行时，返回0；失败返回-1，errno被设为以下的某个值.  
   EINVAL：指定的信号码无效（参数 sig 不合法）。  
   EPERM：权限不够无法传送信号给指定进程。  
   ESRCH：参数 pid 所指定的进程或进程组不存在。  
   * 利用`sigse`设置信号集，进行信号的阻塞
   * 更新的`sigeaction` 设置了结构体进行封装，可以携带信号外的其他数据，具体查找资料，自己没用过。
7. **僵尸进程**：一个子进程在调用return或exit(0)结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个僵尸进程.
   * **僵尸进程的危害**： 僵尸进程是子进程结束时，父进程又没有回收子进程占用的资源。僵尸进程在消失之前会继续占用系统资源。
   * **僵尸进程的解决方法**： 解决僵尸进程的方法有两种
      * 子进程退出之前，会向父进程发送一个信号，父进程调用wait函数等待这个信号，只要等到了，就不会产生僵尸进程。这话说得容易，在并发的服务程序中这是不可能的，因为父进程要做其它的事，例如等待客户端的新连接，不可能去等待子进程的退出信号
      * 另一种方法就是父进程直接忽略子进程的退出信号，具体做法很简单，在主程序中启用以下代码： `signal(SIGCHLD,SIG_IGN); `
      
### I/O多路复用
1. **select** : `int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout)返回值：就绪描述符的数目，超时返回0，出错返回-1`
   该函数准许进程指示内核等待多个事件中的任何一个发送，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒  
   select的几大缺点：
   * 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
   * 同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大
   * select支持的文件描述符数量太小了，默认是1024(每个描述符是通过位图映射的）
   * select是水平触发(LT)，即当此select检测到了fd的事件但是没有处理或者没有完全处理完，select还会立即报告该fd
2. **poll**: `int poll ( struct pollfd * fds, unsigned int nfds, int timeout);`
   ```C++
   struct pollfd {
   int fd;         /* 文件描述符 */
   short events;         /* 等待的事件 */
   short revents;       /* 实际发生了的事件 */
   } ; 
   ```
   每一个pollfd结构体指定了**一个**被监视的文件描述符，可以**传递多个结构体**，指示poll()监视多个文件描述符。每个结构体的events域是监视该文件描述符的事件掩码，由用户来设置这个域。revents域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。
   在select中，不能直接传入原本的fd_set, 而需要创建一个**副本传入**，因为select会**直接修改fd_set会造成原本的fd_set丢失**的情况。
   而在poll中，有事件发生的fd会体现在在revents中，不需要创建临时副本。
   poll的缺点：
   * 与select一样，也需要遍历发生事件的fd，也同样需要用户态和内核态之间切换时间开销过大
   * 也是和select一样的水平触发(LT)，存储是数组(结构体数组)的形式

3. **epoll**:相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。
   ```C++
   int epoll_create(int size);
   int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
   int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
   ```
   * `int epoll_create(int size);` : 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。
    * `int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);` epoll的事件注册函数,它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监    听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：
   EPOLL_CTL_ADD：注册新的fd到epfd中；
   EPOLL_CTL_MOD：修改已经注册的fd的监听事件；
   EPOLL_CTL_DEL：从epfd中删除一个fd；
   第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下：
   ```C++
   struct epoll_event {
     __uint32_t events;  /* Epoll events */
     epoll_data_t data;  /* User data variable */
   };
   ```
   与poll相似
   events可以是以下几个宏的集合：
   EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
   EPOLLOUT：表示对应的文件描述符可以写；
   EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
   EPOLLERR：表示对应的文件描述符发生错误；
   EPOLLHUP：表示对应的文件描述符被挂断；
   **EPOLLET**： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
   EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里
   ET模式：当epoll_wait检测到了fd的事件但是没有处理或者没有完全处理完，下次调用epoll_wait时会再次报告该fd
   ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务    饿死。

## 操作系统
