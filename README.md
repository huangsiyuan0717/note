# note
## C++
1. **右值、移动语义、完美转发及配合lambda**  
   采用**右值**和**移动语义**主要是避免进行过多的副本复制，从而节省系统资源，提高效率  
   
   **右值**：表达式结束时就不存在的临时对象，例如函数返回值，运算表达式等，最简单的查看方法是
   看能否对该值取地址，能则是左指，不能则是右值。  
   
   **左值引用、右值引用**：`&&`表示右值引用，只能绑定右值。 `&`表示左值引用，只能绑定左值。`const &`例外，左值右值都能绑定。模板类`T &&`也都能绑定（也称为通用引用），进行自动推断。 
   
   **右值用法**：通常的拷贝复制函数，和赋值运算函数（=号运算，也会隐式调用复制函数），这些值作为临时的参数值传递给函数时（有的编译器会优化，先不考虑编译器优化），一般会先调用构造函数构建对象，然后在会创建临时的副本接收这个对象，然后传递给函数，这样就造成了资源浪费。采用右值就会告诉编译器，不需要再创建副本，直接把对象传递给函数。具体做法就是构建**移动语义复制构造函数**和**移动语义赋值函数**，例如一个类`MyString`有一个私有变量字符串`char *m_data`,则他的移动赋值构造函数如下
   ```
   MyString(MyString&& str) noexcept
       :m_data(str.m_data) {
       str.m_data = nullptr; //不再指向之前的资源了
   }
   ```
   例如当在`push_back(MyString("hello))`时候，`MyString("hello)`作为临时变量，默认的会新建一个临时副本存储它，然后放入内存。而调用**移动语义赋值**则直接把要添加位置的内存指针指向这个临   时变量。可以理解为移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是"偷"了过来，将自己的指针指向别人的资源，然后将别人的指针修改为`nullptr`,最后把别人的指   针置空也很重要，不置空的话，这个临时对象析构后则后面继承的指针则无数据可以操控，而且后面这个对象的析构也可能会对对同一个地址释放，则会出现不可知的情况。（用`emplace_back()`等效移动语义）  
   调用`std::move()`可以把左值转换成右值  
   
   **完美转发**：所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。  
   ```  
   void process(int& i){
    cout << "process(int&):" << i << endl;
   }
   void myforward(int&& i){
      cout << "myforward(int&&):" << i << endl;
      process(i);
   }

   int main(){
   int a = 0;
   myforward(2);  //右值经过forward函数转交给process函数，却称为了一个左值，
   //原因是该右值有了名字  所以是 process(int&):2
   myforward(move(a));  // 同上，在转发的时候右值变成了左值  process(int&):0
   // forward(a) // 错误用法，右值引用不接受左值
   }  
   ```     
   调用模板类和`std::forward()`则可以解决  
  ```  
  template<typename T>
  void myforward(T && t){
      process(std::forward<T>(t));
  }  
  ```  
  
## 计算机网络/网络编程

## 操作系统
