# note
## C++
1. **右值、移动语义、完美转发及配合lambda**  
   采用**右值**和**移动语义**主要是避免进行过多的副本复制，从而节省系统资源，提高效率  
   
   **右值**：表达式结束时就不存在的临时对象，例如函数返回值，运算表达式等，最简单的查看方法是
   看能否对该值取地址，能则是左指，不能则是右值。  
   
   **左值引用、右值引用**：`&&`表示右值引用，只能绑定右值。 `&`表示左值引用，只能绑定左值。`const &`例外，左值右值都能绑定。模板类`T &&`也都能绑定（也称为通用引用），进行自动推断。 
   
   **右值用法**：通常的拷贝复制函数，和赋值运算函数（=号运算，也会隐式调用复制函数），这些值作为临时的参数值传递给函数时（有的编译器会优化，先不考虑编译器优化），一般会先调用构造函数构建对象，然后在会创建临时的副本接收这个对象，然后传递给函数，这样就造成了资源浪费。采用右值就会告诉编译器，不需要再创建副本，直接把对象传递给函数。具体做法就是构建**移动语义复制构造函数**和**移动语义赋值函数**，例如一个类`MyString`有一个私有变量字符串`char *m_data`,则他的移动赋值构造函数如下
   ```
   MyString(MyString&& str) noexcept
       :m_data(str.m_data) {
       str.m_data = nullptr; //不再指向之前的资源了
   }
   ```
   例如当在`push_back(MyString("hello))`时候，`MyString("hello)`作为临时变量，默认的会新建一个临时副本存储它，然后放入内存。而调用**移动语义赋值**则直接把要添加位置的内存指针指向这个临   时变量。可以理解为移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是"偷"了过来，将自己的指针指向别人的资源，然后将别人的指针修改为`nullptr`,最后把别人的指   针置空也很重要，不置空的话，这个临时对象析构后则后面继承的指针则无数据可以操控，而且后面这个对象的析构也可能会对对同一个地址释放，则会出现不可知的情况。（用`emplace_back()`等效移动语义）  
   调用`std::move()`可以把左值转换成右值  
   
   **完美转发**：所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。  
   ```  
   void process(int& i){
    cout << "process(int&):" << i << endl;
   }
   void myforward(int&& i){
      cout << "myforward(int&&):" << i << endl;
      process(i);
   }

   int main(){
   int a = 0;
   myforward(2);  //右值经过forward函数转交给process函数，却称为了一个左值，
   //原因是该右值有了名字  所以是 process(int&):2
   myforward(move(a));  // 同上，在转发的时候右值变成了左值  process(int&):0
   // forward(a) // 错误用法，右值引用不接受左值
   }  
   ```     
   调用模板类和`std::forward()`则可以解决  
  ```  
  template<typename T>
  void myforward(T && t){
      process(std::forward<T>(t));
  }  
  ```  
  
## 计算机网络

## 网络编程
### 信号
1. **signal信号** :signal信号是进程之间相互传递消息的一种方法，信号全称为软中断信号  
信号只是用来通知某进程发生了什么事件，无法给进程传递任何数据，进程对信号的处理方法有三种：   
   * 第一种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。  
   * 第二种是设置中断的处理函数，收到信号后，由该函数来处理。  
   * 第三种方法是，对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程。
2. **常见信号** :下面是常用到的几个信号  
   信号名|信号值|信号动作|发出的原因
   --|:--:|:--:|--:
   SIGINT|2|终止进程|键盘ctrl+c
   SIGKILL|9|强制终止，无法忽略|发出命令kill -9
   SIGSEGV|11|缺省的动作是终止进程并进行内核映像转储（core dump）|无效的内存引用
   SIGTERM|15|终止进程|发出命令kill
   SIGCHLD|20,17,18|忽略信号|子进程结束信号  
3. **可靠信号/不可靠信号**：1-32是不可靠信号， 34-64是可靠信号。  
   不可靠信号主要会出现信号丢失问题：如果多次发送同一个信号可能会出现丢失，只接受到部分信号。  
4. **信号中断**: 多次同一个信号（可靠信号）会阻塞等待，如果发送其他信号，会优先处理新的信号，等处理函数结束再处理原信号。
5. **信号有什么用**： 服务程序运行在后台，如果想让中止它，强行杀掉不是个好办法，因为程序被杀的时候，程序突然死亡，没有释放资源，会影响系统的稳定，用Ctrl+c中止与杀程序是相同的效果。如果能向后台程序发送一个信号，后台程序收到这个信号后，调用一个函数，在函数中编写释放资源的代码，程序就可以有计划的退出，安全而体面。  
6. **信号的用法**：
   * `sighandler_t signal(int signum, sighandler_t handler);` 第一个参数：信号值， 第二个参数处理函数(SIG_IGN忽略)；
   * `int kill(pid_t pid, int sig);`   
   kill函数将参数sig指定的信号给参数pid 指定的进程。参数pid 有几种情况：  
      1. pid>0 将信号传给进程号为pid 的进程。  
      2. pid=0 将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号。
      3. pid=-1 将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息。  
   sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。  
   返回值说明： 成功执行时，返回0；失败返回-1，errno被设为以下的某个值.  
   EINVAL：指定的信号码无效（参数 sig 不合法）。  
   EPERM：权限不够无法传送信号给指定进程。  
   ESRCH：参数 pid 所指定的进程或进程组不存在。  
   * 利用`sigse`设置信号集，进行信号的阻塞
   * 更新的`sigeaction` 设置了结构体进行封装，可以携带信号外的其他数据，具体查找资料，自己没用过。
7. **僵尸进程**：一个子进程在调用return或exit(0)结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个僵尸进程.
   * **僵尸进程的危害**： 僵尸进程是子进程结束时，父进程又没有回收子进程占用的资源。僵尸进程在消失之前会继续占用系统资源。
   * **僵尸进程的解决方法**： 解决僵尸进程的方法有两种
      * 子进程退出之前，会向父进程发送一个信号，父进程调用wait函数等待这个信号，只要等到了，就不会产生僵尸进程。这话说得容易，在并发的服务程序中这是不可能的，因为父进程要做其它的事，例如等待客户端的新连接，不可能去等待子进程的退出信号
      * 另一种方法就是父进程直接忽略子进程的退出信号，具体做法很简单，在主程序中启用以下代码： `signal(SIGCHLD,SIG_IGN); `
      


 



### I/O多路复用
1. select
2. poll
3. epoll

## 操作系统
